---
export const prerender = false
import DefaultLayout from '../../layouts/DefaultLayout.astro'

const folder = Astro.params.folder

const isAllowed = (name: string) => {
  const i = name.lastIndexOf('.')
  const ext = i >= 0 ? name.slice(i).toLowerCase() : ''
  return ['.jpg','.jpeg','.png','.gif','.mp4','.webm','.ogg'].includes(ext)
}

let meta: any = null
let files: Array<{ name: string; url: string; isVideo: boolean }> = []
let formattedDate: string = ''

async function listAll(bucket: any, options: any) {
  let truncated = true
  let cursor: string | undefined
  const allObjects: any[] = []
  const allPrefixes: Set<string> = new Set()

  while (truncated) {
    const res = await bucket.list({ ...options, cursor })
    truncated = res.truncated
    cursor = res.cursor
    if (res.objects) {
      for (const o of res.objects) allObjects.push(o)
    }
    if (res.delimitedPrefixes) {
      for (const p of res.delimitedPrefixes) allPrefixes.add(p)
    }
    if (!cursor) break
  }

  return { objects: allObjects, delimitedPrefixes: Array.from(allPrefixes) }
}

try {
  const bucket = (Astro.locals as any)?.runtime?.env?.MEDIA_BUCKET
  if (bucket) {
    try {
      const m = await bucket.get(`media/${folder}/meta.txt`)
      if (m) {
        const txt = await m.text()
        const cleanTxt = txt.charCodeAt(0) === 0xFEFF ? txt.slice(1) : txt
        meta = JSON.parse(cleanTxt)
      }
    } catch {}
    
    // Use listAll instead of bucket.list to handle >1000 files
    const listed = await listAll(bucket, { prefix: `media/${folder}/` })
    
    const names = (listed.objects || [])
      .map((o: any) => o.key as string)
      .map((k: string) => k.split('/').pop() || '')
      .filter((n: string) => isAllowed(n))
    files = names.map((n: string) => {
      const isVideo = /\.(mp4|webm|ogg)$/i.test(n)
      const url = `/media/${folder}/${n}`
      return { name: n, url, isVideo }
    })
  }
} catch {}

if (meta?.date) {
  const months = ['Gennaio','Febbraio','Marzo','Aprile','Maggio','Giugno','Luglio','Agosto','Settembre','Ottobre','Novembre','Dicembre']
  const dt = new Date(meta.date)
  formattedDate = `${dt.getDate()} ${months[dt.getMonth()]} ${dt.getFullYear()}`
}
---

<DefaultLayout title={meta?.eventName || folder} description="Galleria immagini dell'evento">
  <main class="bg-gradient-to-br from-red-50/30 via-white to-orange-50/20">
    <section class="relative overflow-hidden pt-6 md:pt-8">
      <div class="relative z-10 container mx-auto px-4 text-center">
        <div class="animate-fade-in">
          <div class="flex items-center justify-center mb-4">
            <div class="hidden md:flex w-12 h-12 rounded-xl sm:rounded-2xl items-center justify-center shadow-md mr-4" style="background: linear-gradient(135deg, #FF2400, #E01E00);">
              <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
              </svg>
            </div>
            <h1 class="text-2xl md:text-3xl font-bold leading-tight">
              <span class="bg-gradient-to-r from-red-700 via-red-600 to-red-500 bg-clip-text text-transparent">{meta?.eventName || folder}</span>
            </h1>
          </div>
          <div class="w-32 h-1.5 rounded-full mx-auto mb-6" style="background: linear-gradient(to right, #FF2400, #E01E00, #CC1A00);"></div>
          <div class="inline-flex items-center justify-center text-sm md:text-base font-semibold text-red-700 bg-red-50 border border-red-200 rounded-full px-3 py-1 mx-auto w-fit">{formattedDate}</div>
          {meta?.description && (
            <p class="mt-6 mb-2 text-base md:text-lg text-gray-700 max-w-3xl mx-auto leading-relaxed">{meta.description}</p>
          )}
        </div>
      </div>
    </section>
    <div class="container mx-auto px-4">
      <div class="mt-2 mb-4">
        <a href="/media" id="backLink" class="inline-flex items-center gap-2 px-3 py-1.5 rounded-lg border border-gray-300 text-gray-700 bg-white/70 hover:bg-gray-50">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
          <span>Torna indietro</span>
        </a>
        <button id="downloadFolder" type="button" data-folder={folder} class="inline-flex items-center gap-2 ml-2 px-3 py-1.5 rounded-lg border border-red-600 text-red-700 bg-white/70 hover:bg-red-50">Scarica cartella</button>
      </div>
    </div>

    <section class="pt-6 pb-16">
      <div class="container mx-auto px-4">
        <div class="bg-white/90 backdrop-blur-sm rounded-xl sm:rounded-2xl shadow-soft border border-gray-200 p-4 md:p-6">
          <div id="gallery" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 md:gap-4">
            {files.map((f, idx) => (
              <div class="rounded-lg overflow-hidden bg-gray-100">
                {f.isVideo ? (
                  <video src={f.url} class="w-full h-40 md:h-48 object-cover" controls></video>
                ) : (
                  <img src={`/cdn-cgi/image/fit=scale-down,width=500,quality=80,format=webp${f.url}`} data-original={f.url} alt={f.name} class="w-full h-40 md:h-48 object-cover cursor-pointer" loading="lazy" data-idx={idx} style="visibility:hidden" />
                )}
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>

    <div id="lightbox" class="fixed inset-0 bg-black/80 hidden items-center justify-center z-50">
      <button id="prevBtn" class="absolute left-4 top-1/2 -translate-y-1/2 w-10 h-10 rounded-full bg-white/20 text-white flex items-center justify-center">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
      </button>
      <button id="nextBtn" class="absolute right-4 top-1/2 -translate-y-1/2 w-10 h-10 rounded-full bg-white/20 text-white flex items-center justify-center">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
      </button>
      <img id="lightboxImg" src="" alt="" class="max-w-[85vw] max-h-[85vh] rounded-xl shadow-strong" />
    </div>
  </main>

  <script>
    // 1. Definiamo le interfacce per window (per fflate)
    interface WindowWithFflate extends Window {
      fflate?: any;
    }

    document.getElementById('backLink')?.addEventListener('click', (e) => {
      e.preventDefault()
      if (history.length > 1) {
        history.back()
      } else {
        location.href = '/media'
      }
    })

    // Recuperiamo gli elementi con il casting corretto (risolve "possibly null")
    const lb = document.getElementById('lightbox') as HTMLDivElement | null
    const lbImg = document.getElementById('lightboxImg') as HTMLImageElement | null
    const prevBtn = document.getElementById('prevBtn') as HTMLButtonElement | null
    const nextBtn = document.getElementById('nextBtn') as HTMLButtonElement | null
    
    // Recuperiamo tutte le immagini della galleria
    const galleryImgs = document.querySelectorAll('#gallery img')
    const imgs: string[] = Array.from(galleryImgs).map(el => el.getAttribute('data-original') || '')
    
    let current = 0

    // Risolve: Parameter 'src' implicitly has an 'any' type
    const setSizeForSrc = (src: string) => {
      if (!lbImg) return
      const temp = new Image()
      temp.onload = () => {
        const maxW = window.innerWidth * 0.8
        const maxH = window.innerHeight * 0.8
        const scale = Math.min(maxW / temp.naturalWidth, maxH / temp.naturalHeight)
        const w = Math.round(temp.naturalWidth * scale)
        const h = Math.round(temp.naturalHeight * scale)
        lbImg.style.width = w + 'px'
        lbImg.style.height = h + 'px'
      }
      temp.src = src
    }

    // Risolve: Parameter 'idx' implicitly has an 'any' type
    const showIndex = (idx: number) => {
      if (!lb || !lbImg) return
      current = idx
      const src = imgs[current]
      if (src) {
        lbImg.src = src
        setSizeForSrc(src)
        lb.classList.remove('hidden')
        lb.classList.add('flex')
        document.body.style.overflow = 'hidden'
      }
    }

    galleryImgs.forEach((el) => {
      el.addEventListener('click', (e) => {
        const target = e.currentTarget as HTMLElement
        const idx = Number(target.getAttribute('data-idx'))
        showIndex(idx)
      })
    })

    const close = () => {
      if (!lb) return
      lb.classList.add('hidden')
      lb.classList.remove('flex')
      document.body.style.overflow = 'unset'
    }

    lb?.addEventListener('click', close)
    
    document.addEventListener('keydown', (e) => {
      if (!lb || lb.classList.contains('hidden')) return
      if (e.key === 'Escape') close()
      if (e.key === 'ArrowLeft') { showIndex((current - 1 + imgs.length) % imgs.length) }
      if (e.key === 'ArrowRight') { showIndex((current + 1) % imgs.length) }
    })

    prevBtn?.addEventListener('click', (e) => { e.stopPropagation(); showIndex((current - 1 + imgs.length) % imgs.length) })
    nextBtn?.addEventListener('click', (e) => { e.stopPropagation(); showIndex((current + 1) % imgs.length) })

    window.addEventListener('resize', () => {
      if (!lb || !lbImg || lb.classList.contains('hidden')) return
      const src = lbImg.getAttribute('src')
      if (src) setSizeForSrc(src)
    })

    async function ensureFflate() {
      const g = window as WindowWithFflate
      if (g.fflate) return g.fflate
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/fflate/umd/index.min.js';
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s)
      })
      return g.fflate
    }

    async function downloadAll() {
      // Risolve: Cannot find name 'folder'
      // Recuperiamo la cartella dall'attributo data-folder del pulsante
      const btn = document.getElementById('downloadFolder')
      const folderName = btn?.getAttribute('data-folder') || 'download'

      try {
        const fflate = await ensureFflate()
        const overlay = document.createElement('div')
        overlay.className = 'fixed inset-0 bg-black/40 z-50 flex items-center justify-center'
        
        const card = document.createElement('div')
        card.className = 'bg-white rounded-xl p-4 w-80 text-center shadow-lg'
        
        const title = document.createElement('div')
        title.className = 'text-sm font-semibold text-gray-800'
        title.textContent = 'Preparazione download â€” non chiudere la pagina'
        
        const barBox = document.createElement('div')
        barBox.className = 'w-full bg-gray-200 rounded-full h-2 mt-3 overflow-hidden'
        
        const bar = document.createElement('div')
        bar.className = 'bg-red-600 h-2 rounded-full'
        bar.style.width = '0%'
        
        const pct = document.createElement('div')
        pct.className = 'text-xs text-gray-700 mt-2'
        pct.textContent = '0%'
        
        barBox.appendChild(bar)
        card.appendChild(title)
        card.appendChild(barBox)
        card.appendChild(pct)
        overlay.appendChild(card)
        document.body.appendChild(overlay)
        
        const imgs = Array.from(document.querySelectorAll('#gallery img')).map(el => ({ name: el.getAttribute('alt') || 'file', url: el.getAttribute('data-original') || '' }))
        const vids = Array.from(document.querySelectorAll('#gallery video')).map(el => {
          const url = el.getAttribute('src') || ''
          const name = url.split('/').pop() || 'video'
          return { name, url }
        })
        
        const all = [...imgs, ...vids].filter(it => it.url)
        const list = all.filter(it => {
          const n = (it.name || '').toLowerCase()
          const u = (it.url || '').toLowerCase()
          return !(n.endsWith('.webp') || u.endsWith('.webp'))
        })
        
        let loaded = 0
        const total = list.length
        const map: any = {}
        
        for (const it of list) {
          const res = await fetch(it.url)
          const ab = await res.arrayBuffer()
          const u8 = new Uint8Array(ab)
          map[it.name] = u8
          loaded++
          const percent = Math.round((loaded / total) * 100)
          bar.style.width = percent + '%'
          pct.textContent = percent + '%'
        }
        
        const zip = fflate.zipSync(map, { level: 0 })
        const blob = new Blob([zip], { type: 'application/zip' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = `${folderName}.zip`
        document.body.appendChild(a)
        a.click()
        URL.revokeObjectURL(url)
        setTimeout(() => { overlay.remove() }, 500)
      } catch (e) {
        console.error('downloadAll:error', e)
        alert('Errore nel preparare il download')
      }
    }

    document.getElementById('downloadFolder')?.addEventListener('click', downloadAll)

    function cfLowRes(url: string) {
      if (!url) return url
      const path = url.startsWith('/') ? url : '/' + url
      return `/cdn-cgi/image/fit=scale-down,width=500,quality=80,format=webp${path}`
    }

    document.querySelectorAll('#gallery img').forEach(async (el) => {
      try {
        const orig = el.getAttribute('data-original') || ''
        let useLow = false
        try {
          const r = await fetch(orig, { method: 'HEAD', cache: 'no-store' })
          const cl = Number(r.headers.get('content-length') || '0')
          useLow = cl > 1024 * 1024
        } catch {}
        
        const src = useLow ? cfLowRes(orig) : orig
        el.setAttribute('src', src)
        el.addEventListener('load', () => {
          try { (el as HTMLImageElement).style.visibility = 'visible' } catch {}
        })
        el.addEventListener('error', () => {
          try { (el.parentElement)?.remove() } catch {}
        })
      } catch {}
    })
  </script>
</DefaultLayout>